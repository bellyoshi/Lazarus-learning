# PDFビューアーアプリケーション開発ガイド
## Lazarus/Free Pascal によるPDF表示システムの実装

### 目次
1. プロジェクト概要
2. アーキテクチャ設計
3. 各モジュールの詳細解説
4. 実装のポイントとベストプラクティス
5. まとめ

---

## 1. プロジェクト概要

本プロジェクトは、Lazarus/Free Pascal環境で開発されたPDFビューアーアプリケーションです。GoogleのPDFiumライブラリを活用し、PDFファイルの読み込み、表示、ページナビゲーション機能を提供します。

### 主要機能
- PDFファイルの読み込みと表示
- ページ間のナビゲーション（前へ/次へ）
- リアルタイムでのページ情報表示
- エラーハンドリングとユーザーフレンドリーなインターフェース

### 技術スタック
- **開発環境**: Lazarus IDE
- **プログラミング言語**: Free Pascal/Object Pascal
- **PDF処理ライブラリ**: PDFium (Google)
- **UI フレームワーク**: LCL (Lazarus Component Library)
- **プラットフォーム**: Windows (x64)

---

## 2. アーキテクチャ設計

### 2.1 モジュール構成

アプリケーションは以下の5つの主要モジュールで構成されています：

```
project1.lpr          # メインプログラム
├── unit1.pas         # メインフォーム（UI制御）
├── pdfimagecreator.pas # PDF画像生成モジュール
├── PdfiumCore.pas    # PDFiumコア機能
├── PdfBitmap.pas     # ビットマップ処理
└── PdfiumLib.pas     # PDFium API バインディング
```

### 2.2 設計原則

1. **関心の分離**: 各モジュールは明確な責任を持つ
2. **依存関係の最小化**: モジュール間の結合度を低く保つ
3. **再利用性**: 独立したモジュールとして他のプロジェクトでも利用可能
4. **保守性**: コードの可読性と拡張性を重視

---

## 3. 各モジュールの詳細解説

### 3.1 PdfiumLib.pas - PDFium API バインディング

```pascal
unit PdfiumLib;

{$MODE DelphiUnicode}
{$A8,B-,E-,F-,G+,H+,I+,J-,K-,M-,N-,P+,Q-,R-,S-,T-,U-,V+,X+,Z1}
{$STRINGCHECKS OFF}
```

このモジュールは、PDFiumライブラリのC APIをPascalから呼び出せるようにするバインディング層です。

#### 主要な型定義

```pascal
type
  __FPDF_PTRREC = record end;
  __PFPDF_PTRREC = ^__FPDF_PTRREC;
  
  FPDF_BITMAP = type __PFPDF_PTRREC;
  FPDF_DOCUMENT = type __PFPDF_PTRREC;
  FPDF_PAGE = type __PFPDF_PTRREC;
  FPDF_DWORD = Cardinal;
  FPDF_STRING = PAnsiChar;
  FPDF_BYTESTRING = PAnsiChar;
```

これらの型は、PDFiumライブラリの内部構造体へのポインタを型安全に扱うためのものです。`__FPDF_PTRREC`は空のレコードとして定義され、実際の構造体はCライブラリ側で管理されます。

#### 外部関数宣言

```pascal
procedure FPDF_InitLibrary(); cdecl; external PDFiumDll name 'FPDF_InitLibrary';
procedure FPDF_DestroyLibrary(); cdecl; external PDFiumDll name 'FPDF_DestroyLibrary';

function FPDF_LoadDocument(file_path: FPDF_STRING; password: FPDF_BYTESTRING): FPDF_DOCUMENT; cdecl; external PDFiumDll;
procedure FPDF_CloseDocument(document: FPDF_DOCUMENT); cdecl; external PDFiumDll;
function FPDF_GetPageCount(document: FPDF_DOCUMENT): Integer; cdecl; external PDFiumDll;
```

`cdecl`呼び出し規約を使用し、Cライブラリとの互換性を確保しています。`external PDFiumDll`により、実行時にpdfium.dllから関数を動的に読み込みます。

### 3.2 PdfBitmap.pas - ビットマップ処理モジュール

```pascal
unit PdfBitmap;

type
  TPdfBitmapFormat = (
    bfGrays = 1,  // グレースケール
    bfBGR   = 2,  // BGR形式
    bfBGRx  = 3,  // BGRx形式
    bfBGRA  = 4   // BGRA形式（アルファチャンネル付き）
  );
```

このモジュールは、PDFiumのビットマップ操作を抽象化し、Pascalのオブジェクト指向パラダイムで扱いやすくします。

#### TPdfBitmapクラス

```pascal
TPdfBitmap = class(TObject)
private
  FBitmap: FPDF_BITMAP;
  FOwnsBitmap: Boolean;
  FWidth: Integer;
  FHeight: Integer;
public
  constructor Create(ABitmap: FPDF_BITMAP; AOwnsBitmap: Boolean = False); overload;
  constructor Create(AWidth, AHeight: Integer; AFormat: TPdfBitmapFormat); overload;
  destructor Destroy; override;
  
  procedure FillRect(ALeft, ATop, AWidth, AHeight: Integer; AColor: FPDF_DWORD);
  function GetBuffer: Pointer;
  
  property Width: Integer read FWidth;
  property Height: Integer read FHeight;
  property Bitmap: FPDF_BITMAP read FBitmap;
end;
```

#### コンストラクタの実装

```pascal
constructor TPdfBitmap.Create(ABitmap: FPDF_BITMAP; AOwnsBitmap: Boolean);
begin
  inherited Create;
  FBitmap := ABitmap;
  FOwnsBitmap := AOwnsBitmap;
  if FBitmap <> nil then
  begin
    FWidth := FPDFBitmap_GetWidth(FBitmap);
    FHeight := FPDFBitmap_GetHeight(FBitmap);
  end;
end;

constructor TPdfBitmap.Create(AWidth, AHeight: Integer; AFormat: TPdfBitmapFormat);
begin
  Create(FPDFBitmap_CreateEx(AWidth, AHeight, Ord(AFormat), nil, 0), True);
end;
```

2つのコンストラクタを提供し、既存のビットマップをラップする場合と新規作成する場合に対応しています。`FOwnsBitmap`フラグにより、デストラクタでのメモリ解放を制御します。

### 3.3 PdfiumCore.pas - PDFiumコア機能

このモジュールは、PDFドキュメントとページの管理を担当する中核的な機能を提供します。

#### TPdfDocumentクラス

```pascal
TPdfDocument = class(TObject)
private
  FDocument: FPDF_DOCUMENT;
  FPages: TObjectList;
  FFileName: string;
  FClosing: Boolean;
  
  procedure InternLoadFromFile(const FileName: string; const Password: UTF8String);
  function GetPage(Index: Integer): TPdfPage;
  function GetPageCount: Integer;
  procedure ExtractPage(APage: TPdfPage);
  function ReloadPage(APage: TPdfPage): FPDF_PAGE;
  procedure DocumentLoaded;
public
  constructor Create;
  destructor Destroy; override;
  
  procedure LoadFromFile(const FileName: string; const Password: UTF8String = '');
  procedure Close;
  
  property FileName: string read FFileName;
  property PageCount: Integer read GetPageCount;
  property Pages[Index: Integer]: TPdfPage read GetPage;
end;
```

#### ドキュメント読み込み処理

```pascal
procedure TPdfDocument.LoadFromFile(const FileName: string; const Password: UTF8String);
begin
  Close;
  InternLoadFromFile(FileName, Password);
  FFileName := FileName;
end;

procedure TPdfDocument.InternLoadFromFile(const FileName: string; const Password: UTF8String);
var
  Utf8FileName: UTF8String;
begin
  Utf8FileName := UTF8Encode(FileName);
  FDocument := FPDF_LoadDocument(PAnsiChar(Utf8FileName), PAnsiChar(Pointer(Password)));
  DocumentLoaded;
end;
```

ファイル名をUTF-8エンコードしてからPDFiumに渡し、パスワード保護されたPDFにも対応しています。

#### TPdfPageクラス

```pascal
TPdfPage = class(TObject)
private
  FDocument: TPdfDocument;
  FPage: FPDF_PAGE;
  procedure Open;
public
  constructor Create(ADocument: TPdfDocument; APage: FPDF_PAGE);
  destructor Destroy; override;
  procedure Close;
  procedure DrawToPdfBitmap(APdfBitmap: TPdfBitmap; X, Y, Width, Height: Integer);
end;
```

ページの遅延読み込み（Lazy Loading）を実装し、必要な時のみページをメモリに読み込みます。

#### ライブラリ初期化

```pascal
procedure InitLib;
{$J+}
const
  Initialized: boolean = false;
{$J-}
begin
  if not Initialized then
  begin
    SetExceptionMask([exInvalidOp, exDenormalized, exZeroDivide, exOverflow, exUnderflow, exPrecision]);
    FPDF_InitLibrary();
    Initialized := true;
  end;
end;
```

`{$J+}`ディレクティブにより、定数の値を変更可能にし、一度だけ初期化されることを保証しています。64ビット環境では、浮動小数点例外をマスクしてPDFiumの動作を安定させます。

### 3.4 pdfimagecreator.pas - PDF画像生成モジュール

このモジュールは、PDFページをDelphiのTBitmapに変換する機能を提供します。

#### TPdfImageCreatorクラス

```pascal
TPdfImageCreator = class
private
  FPdfDocument: TPdfDocument;
  FPageIndex: Integer;
  procedure SetPageIndex(AValue: Integer);
public
  constructor Create(const Filename: string; PageIndex: Integer = 0);
  destructor Destroy; override;
  function GetBitmap(Width, Height: Integer): TBitmap;
  function GetPageCount: Integer;
  property PageCount: Integer read GetPageCount;
  property PageIndex: Integer read FPageIndex write SetPageIndex;
end;
```

#### ビットマップ変換処理

```pascal
procedure DrawToBitmap(Page: TPdfPage; Bitmap: TBitmap; w, h: Integer);
var
  SizeInt: Integer;
  PdfBitmap: TPdfBitmap;
  AIMarge: TBytes;
  buffer: Pointer;
  RawImage: TRawImage;
begin
  PdfBitmap := TPdfBitmap.Create(w, h, bfBGRA);
  try
    PdfBitmap.FillRect(0, 0, w, h, $FFFFFFFF);
    Page.DrawToPdfBitmap(PdfBitmap, 0, 0, w, h);

    SizeInt := w * h * 4;
    AIMarge := nil;
    SetLength(AIMarge, SizeInt);

    buffer := PdfBitmap.GetBuffer;
    Move(buffer^, AIMarge[0], SizeInt);

    RawImage.Init;
    RawImage.Description.Init_BPP32_B8G8R8A8_M1_BIO_TTB(w, h);
    RawImage.CreateData(true);
    RawImage.Data := @AIMarge[0];

    Bitmap.LoadFromRawImage(RawImage, false);
  finally
    PdfBitmap.Free;
  end;
end;
```

この処理では以下の手順でPDFページをビットマップに変換します：

1. PDFiumビットマップを作成（BGRA形式）
2. 背景を白色で塗りつぶし
3. PDFページをビットマップに描画
4. ビットマップデータをバイト配列にコピー
5. RawImageを使用してDelphiのTBitmapに変換

### 3.5 unit1.pas - メインフォーム

このモジュールは、ユーザーインターフェースとアプリケーションの制御ロジックを担当します。

#### フォーム設計

```pascal
TForm1 = class(TForm)
  Image1: TImage;           // PDF表示用
  OpenDialog1: TOpenDialog; // ファイル選択ダイアログ
  Button1: TButton;         // ファイルを開く
  Button2: TButton;         // 前のページ
  Button3: TButton;         // 次のページ
  Label1: TLabel;           // タイトル
  Label2: TLabel;           // ページ情報
  Memo1: TMemo;             // ログ表示（未使用）
private
  FPdfImageCreator: TPdfImageCreator;
  FCurrentPage: Integer;
  procedure LoadPdfFile(const FileName: string);
  procedure UpdatePageDisplay;
  procedure UpdatePageInfo;
end;
```

#### PDFファイル読み込み処理

```pascal
procedure TForm1.LoadPdfFile(const FileName: string);
begin
  try
    if Assigned(FPdfImageCreator) then
      FPdfImageCreator.Free;
    
    FPdfImageCreator := TPdfImageCreator.Create(FileName, 0);
    FCurrentPage := 0;
    
    UpdatePageDisplay;
    UpdatePageInfo;
    
    Caption := 'PDF Viewer - ' + ExtractFileName(FileName);
  except
    on E: Exception do
    begin
      ShowMessage('PDFファイルの読み込みに失敗しました: ' + E.Message);
      if Assigned(FPdfImageCreator) then
      begin
        FPdfImageCreator.Free;
        FPdfImageCreator := nil;
      end;
    end;
  end;
end;
```

エラーハンドリングを適切に実装し、ユーザーに分かりやすいメッセージを表示します。

#### ページ表示更新

```pascal
procedure TForm1.UpdatePageDisplay;
var
  Bitmap: TBitmap;
begin
  if not Assigned(FPdfImageCreator) then
  begin
    Image1.Picture.Clear;
    Exit;
  end;
  
  try
    FPdfImageCreator.PageIndex := FCurrentPage;
    Bitmap := FPdfImageCreator.GetBitmap(Image1.Width, Image1.Height);
    try
      Image1.Picture.Assign(Bitmap);
    finally
      Bitmap.Free;
    end;
  except
    on E: Exception do
      ShowMessage('ページの表示に失敗しました: ' + E.Message);
  end;
end;
```

リソースの適切な管理（try-finally文）により、メモリリークを防いでいます。

### 3.6 project1.lpr - メインプログラム

```pascal
program project1;

{$mode objfpc}{$H+}

uses
  {$IFDEF UNIX}
  cthreads,
  {$ENDIF}
  {$IFDEF HASAMIGA}
  athreads,
  {$ENDIF}
  Interfaces,
  Forms, Unit1, PdfImageCreator, PdfiumCore, PdfiumLib, PdfBitmap,
  Classes, SysUtils, Windows;

{$R *.res}

begin
  RequireDerivedFormResource := True;
  Application.Scaled := True;
  {$PUSH}{$WARN 5044 OFF}
  Application.MainFormOnTaskbar := True;
  {$POP}
  Application.Initialize;
  Application.CreateForm(TForm1, Form1);
  Application.Run;
end.
```

クロスプラットフォーム対応のための条件コンパイルディレクティブを使用し、各プラットフォームに適したスレッドライブラリを読み込みます。

---

## 4. 実装のポイントとベストプラクティス

### 4.1 メモリ管理

#### RAIIパターンの適用
```pascal
// 良い例
Bitmap := TBitmap.Create;
try
  // ビットマップを使用
finally
  Bitmap.Free;
end;

// 悪い例
Bitmap := TBitmap.Create;
// 使用後、Freeを忘れるとメモリリーク
```

#### オブジェクトの所有権管理
```pascal
// TPdfBitmapクラスでの所有権管理
constructor TPdfBitmap.Create(ABitmap: FPDF_BITMAP; AOwnsBitmap: Boolean);
begin
  FBitmap := ABitmap;
  FOwnsBitmap := AOwnsBitmap;  // 所有権を明示的に管理
end;

destructor TPdfBitmap.Destroy;
begin
  if FOwnsBitmap and (FBitmap <> nil) then
    FPDFBitmap_Destroy(FBitmap);  // 所有している場合のみ解放
  inherited Destroy;
end;
```

### 4.2 エラーハンドリング

#### 例外処理の階層化
```pascal
procedure TForm1.LoadPdfFile(const FileName: string);
begin
  try
    // PDF読み込み処理
  except
    on E: Exception do
    begin
      // ユーザーフレンドリーなエラーメッセージ
      ShowMessage('PDFファイルの読み込みに失敗しました: ' + E.Message);
      // リソースのクリーンアップ
      if Assigned(FPdfImageCreator) then
      begin
        FPdfImageCreator.Free;
        FPdfImageCreator := nil;
      end;
    end;
  end;
end;
```

### 4.3 パフォーマンス最適化

#### 遅延読み込み（Lazy Loading）
```pascal
function TPdfDocument.GetPage(Index: Integer): TPdfPage;
var
  LPage: FPDF_PAGE;
begin
  Result := TPdfPage(FPages[Index]);
  if Result = nil then
  begin
    // 必要な時のみページを読み込み
    LPage := FPDF_LoadPage(FDocument, Index);
    Result := TPdfPage.Create(Self, LPage);
    FPages[Index] := Result;
  end
end;
```

#### ビットマップの効率的な変換
```pascal
// 直接メモリコピーによる高速変換
buffer := PdfBitmap.GetBuffer;
Move(buffer^, AIMarge[0], SizeInt);
```

### 4.4 コードの可読性と保守性

#### 意味のある変数名
```pascal
// 良い例
FCurrentPage: Integer;
FPdfImageCreator: TPdfImageCreator;

// 悪い例
i: Integer;
obj: TObject;
```

#### 適切なコメント
```pascal
// 複雑な処理には説明を追加
// PDFiumは64ビットモードで全ての算術例外をマスクする必要がある
SetExceptionMask([exInvalidOp, exDenormalized, exZeroDivide, exOverflow, exUnderflow, exPrecision]);
```

---

## 5. まとめ

### 5.1 プロジェクトの成果

本PDFビューアーアプリケーションは、以下の技術的成果を達成しました：

1. **モジュラー設計**: 各機能が独立したモジュールとして実装され、保守性と再利用性が向上
2. **効率的なメモリ管理**: RAIIパターンと適切なリソース管理により、メモリリークを防止
3. **堅牢なエラーハンドリング**: ユーザーフレンドリーなエラーメッセージと適切なリソースクリーンアップ
4. **クロスプラットフォーム対応**: 条件コンパイルにより、複数のプラットフォームに対応
5. **パフォーマンス最適化**: 遅延読み込みと効率的なビットマップ変換

### 5.2 技術的学習ポイント

#### PDFiumライブラリの活用
- C APIのPascalバインディングの実装方法
- 外部DLLとの連携におけるメモリ管理
- プラットフォーム固有の設定（例外マスクなど）

#### オブジェクト指向設計
- 関心の分離によるモジュール設計
- 継承とポリモーフィズムの適切な使用
- インターフェースと実装の分離

#### ユーザーインターフェース設計
- イベント駆動プログラミング
- 非同期処理とUI応答性
- エラー状態の適切な表示

### 5.3 今後の拡張可能性

このアプリケーションは、以下の機能拡張が可能です：

1. **ズーム機能**: マウスホイールやボタンによる拡大・縮小
2. **検索機能**: テキスト検索とハイライト表示
3. **印刷機能**: PDFページの直接印刷
4. **注釈機能**: テキストや図形の追加
5. **複数タブ対応**: 複数のPDFファイルを同時に開く

### 5.4 開発におけるベストプラクティス

1. **段階的開発**: 小さな機能単位で実装し、テストを繰り返す
2. **コードレビュー**: 定期的なコードレビューによる品質向上
3. **ドキュメント化**: コードの意図と設計思想を文書化
4. **テスト駆動開発**: 単体テストと統合テストの実装
5. **継続的改善**: リファクタリングによるコード品質の向上

---

このPDFビューアーアプリケーションは、Lazarus/Free Pascalの強力な機能とPDFiumライブラリの組み合わせにより、実用的で拡張性の高いソリューションを実現しています。各モジュールの設計と実装は、オブジェクト指向プログラミングの原則に従い、保守性と再利用性を重視したものとなっています。

開発者は、このコードベースを参考に、より高度なPDF処理アプリケーションの開発に取り組むことができます。また、各モジュールの設計パターンは、他のドキュメント処理アプリケーションにも応用可能です。

技術的な詳細と実装のポイントを理解することで、PDFiumライブラリを活用した高品質なアプリケーション開発の基盤が得られるでしょう。
